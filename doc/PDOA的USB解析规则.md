
# 数据解析及角度计算

本文档详细介绍了如何从 JSON 格式的原始数据中提取 `Xcm` 和 `Ycm` 并计算角度，以及如何解析十六进制格式的距离和角度数据，包括负角度的补码转换过程。

## 1. 原始数据格式

原始数据为 JSON 格式，包含 `TWR` 字段，其中包含 `Xcm` 和 `Ycm` 等信息。例如：

```json
JS006D{"TWR": {"a16":"8834","R":128,"T":1490981,"D":37,"P":56,"Xcm":14,"Ycm":32,"O":0,"V":49152,"X":0,"Y":0,"Z":0}}
JS006C{"TWR": {"a16":"8834","R":46,"T":46111,"D":93,"P":-63,"Xcm":-31,"Ycm":84,"O":0,"V":49152,"X":0,"Y":0,"Z":0}}
JS00A4{"TWR": {"a16":"8834","R":46,"T":46111,"D":93,"P":-63,"Xcm":-31,"Ycm":84,"O":0,"V":49152,"X":0,"Y":0,"Z":0}}
```

```json
{
  "35006C": { // 数据块标识
    "TWR": {
      "a16": "4096", // Tag 地址 (十六进制)
      "R": 115,      // Tag 序列号
      "T": 0,        // Tag 时间 (时间戳或计数)
      "D": 76,       // Tag 与 Node 的距离值 
      "P": -123,     // Tag 与 Node 的相位差 (可能是角度或其他单位)
      "Xcm": -57,   // Tag 的 x 轴坐标 (厘米)
      "Ycm": 50,    // Tag 的 y 轴坐标 (厘米)
      "0": 408,      // 时钟偏移 (可能用于时间同步)
      "V": 49152,    // Tag 的信息 (可能是状态、版本或其他信息)
      "X": 0,        // Tag 的加速度 x 轴信息
      "Y": 0,        // Tag 的加速度 y 轴信息
      "Z": 0         // Tag 的加速度 z 轴信息
    }
  }
}
```

## 2. 角度计算

使用 `Xcm` 和 `Ycm` 计算角度的公式如下：

```
angle = arctan(Xcm / Ycm) × 180 / π
```

**示例：**

当 `Xcm = 14`，`Ycm = 32` 时：

```
angle = arctan(14 / 32) × 180 / π
angle = arctan(0.4375) × 57.2958
angle ≈ 23.62°
```

## 3. 十六进制数据解析

以下示例展示了如何解析十六进制格式的角度和距离数据。

**原始数据示例：**

```
2A
1B
CF
34 88
EF FF FF FF                    角度
38 00 00 00                   距离
00 C0
00 00 00 00
00 00 00 00
00 00
00 00
00 00
9B
23
```

**解析规则：**

* **规则一（距离）：** 距离数据按位数直接转换为十进制，单位为厘米（cm）。
* **规则二（角度）：** 角度分为正角度和负角度。正角度以 `00` 开头，负角度以 `FF` 开头。正角度直接转换为十进制即可。负角度需要进行补码转换。

**示例解析：**

**距离：**

数据 `38 00 00 00` 直接转换为十进制为 `56`，因此距离为 `56 cm`。

**角度：**

数据 `EF FF FF FF` 的解析步骤如下：

1. **分析原始数据：** `EF FF FF FF` 是一个小端序的 32 位数据。

2. **转换为大端序：** 将字节反转，得到大端序：`FF FF FF EF`。

3. **识别符号位：** 大端序的最高位是 `F`（二进制 `1111`），表明这是一个负数。

4. **补码到十进制转换：**

    (1) **确定补码形式：** `FF FF FF EF` 的二进制形式为：`1111 1111 1111 1111 1111 1111 1110 1111`

    (2) **取反：** 将所有位取反（`1` 变 `0`，`0` 变 `1`），得到：`0000 0000 0000 0000 0000 0000 0001 0000`

    (3) **加 1：** 取反结果加 1，得到：`0000 0000 0000 0000 0000 0000 0001 0001`

    (4) **转换为十进制：** 上述结果的十进制表示为 `17`。由于原始数据是负数，所以最终结果为 `-17`。

**最终结果：**

因此，`EF FF FF FF` 按照补码表示，解读为十进制的 `-17`。
